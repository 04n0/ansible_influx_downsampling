---

- name: '{{ansible_influx_databases[database].name}} - Set database variable'
  set_fact:
    ifx_db: "{{ansible_influx_databases[database]
      |combine({ 'continuous_query': '' } if ansible_influx_databases[database].continuous_query is not defined
      else { 'continuous_query': ansible_influx_databases[database].continuous_query })}}"

# some assertions - move to separate file?
- name: "Assert basic DB attributes"
  fail:
    msg: "DB attribute 'name' must be defined!"
  when: ifx_db.name is not defined

- name: "Assert 'retention_policy' with 'amount'+'unit' is defined"
  fail:
    msg: "DB attribute 'retention_policy' with 'amount'+'unit' or 'name' must be defined!"
  when: not (ifx_db.retention_policy is defined and (
      (ifx_db.retention_policy.amount is defined and ifx_db.retention_policy.unit is defined)
      or ifx_db.retention_policy.name is defined
    ))

# for all
# if source or measurement -> source + measurement

# for mode=setup
# source + cq+interval OR nothing

# for mode=migrate 
# source 
# + cq+interval
# + backfill[+interval]
# source RP name can be empty = default -> check for a default RP!

# for mode=compact
# source 
# + backfill+interval
# RP.default must be true when source.drop_after_backfill is true

- name: "Assert 'interval' must be defined when 'measurements' are defined"
  fail:
    msg: "DB attribute 'continuous_query.interval' OR 'backfill.interval' must be defined when defining 'measurements'!"
  when: ifx_db.measurements is defined and (
    ifx_db.continuous_query.interval is not defined
    and ifx_db.backfill.interval is not defined)

- name: "Assert 'source' must be defined for backfilling or continuous queries"
  fail:
    msg: "DB attribute 'source' is required for 'backfill' or 'continuous_query'"
  when: ifx_db.source is not defined and (
    ifx_db.continuous_query.interval is defined
    or (ifx_db.backfill is defined and ifx_db.backfill.interval is defined))

- name: "Assert backfill settings 'step' and 'source'"
  fail:
    msg: "DB attribute 'backfill.step' and 'backfill.interval' require 'source'!"
  when: ifx_db.backfill is defined and (
    ifx_db.backfill.step is defined or ifx_db.backfill.interval is defined
    ) and ifx_db.source is not defined

- name: "Assert backfill RP dependency"
  fail:
    msg: "DB attribute 'backfill' requires 'retention_policy' with 'amount' + 'unit'!"
  when: ifx_db.backfill is defined and (
    ifx_db.retention_policy is not defined
    or ifx_db.retention_policy.amount is not defined
    or ifx_db.retention_policy.unit is not defined)

# REFACTOR!
# type/case/mode = compact, setup, migrate (defines which variables are required/used and which are not)
# compact : create RP, backfill (no CQ) per measurement, backfill last Xhours, switch RP
# setup : create RP, setup CQ per measurement
# migrate : create RP, backfill and setup CQ per measurement

- name: '{{ifx_db.name}} - Set defaults'
  set_fact:
    db_prefix: "{{ifx_db.name}} -"
    ifx_rp_name: "{{ifx_db.retention_policy.name if ifx_db.retention_policy.name is defined 
      else 'rp_'+ifx_db.retention_policy.amount+ifx_db.retention_policy.unit}}"
    ifx_source_rp_name: "{{ifx_db.source.rp_name|default('') if ifx_db.source is defined else ''}}"
    ifx_rp_duration: "{{ifx_db.retention_policy.amount+ifx_db.retention_policy.unit
      if ifx_db.retention_policy.amount is defined and ifx_db.retention_policy.unit is defined
      else '0s'}}"
    ifx_cq_name: "{{ifx_db.continuous_query.interval if ifx_db.continuous_query.interval is defined else 'all'}}"
    ifx_bf_where: "{{'AND '+ifx_db.continuous_query.where if ifx_db.continuous_query.where is defined else ''}}"
    ifx_cq_where: "{{'WHERE '+ifx_db.continuous_query.where if ifx_db.continuous_query.where is defined else ''}}"
    ifx_cq_groupby: "{{ifx_db.continuous_query.groupby if ifx_db.continuous_query.groupby is defined else ['*']}}"
    ifx_cq_interval: "{{'time('+ifx_db.continuous_query.interval+')'
      if ifx_db.continuous_query is defined and ifx_db.continuous_query.interval is defined else
        'time('+ifx_db.backfill.interval+')' if ifx_db.backfill is defined and ifx_db.backfill.interval is defined
          and ifx_db.backfill.interval != '*' else '*'
      }}"
    ifx_cq_offset: "{{ifx_db.continuous_query.offset|default(0)}}"
    ifx_cq_resample: "{{'RESAMPLE ' if ifx_db.continuous_query.resample is defined else ''}}"
    ifx_cq_resample_every: "{{'EVERY '+ifx_db.continuous_query.resample.every
      if ifx_db.continuous_query.resample is defined and ifx_db.continuous_query.resample.every is defined else ''}}"
    ifx_cq_resample_for: "{{'FOR '+ifx_db.continuous_query.resample.for if ifx_db.continuous_query.resample is defined
      and ifx_db.continuous_query.resample.for is defined else ''}}"
    ifx_cq_recreate: "{{recreate_cqs == 'yes'}}"
    ifx_backfill: "{{ifx_db.backfill|default(false)}}"
    ifx_backfill_stats: "{{ifx_db.backfill.stats|default(false) if ifx_db.backfill is defined else false}}"
    ifx_backfill_force: "{{ifx_db.backfill.force|default(false) if ifx_db.backfill is defined else false}}"
    ifx_source_drop: "{{ifx_db.source.drop_after_backfill|default(false) if ifx_db.source is defined else false}}"
    # when retention_policy.default=true, unless drop after backfill
    ifx_rp_default: "{{'DEFAULT' if 
      ifx_db.retention_policy.default|default(false)
      and not (ifx_db.source is defined and ifx_db.source.drop_after_backfill|default(false))
      else ''}}"
    mm_backfill_totals: []
    mm_downsampling_totals: []

- name: '{{db_prefix}} Database definition'
  debug: var=ifx_db

- name: '{{db_prefix}} Create database'
  uri: url="{{ansible_influx_url}}/query" method=POST body="q=CREATE DATABASE {{ifx_db.name}}" return_content=yes
  when: ifx_db.name not in ifx_dbs
  register: ansible_influx_db_create
  changed_when: ansible_influx_db_create.status == 200 and ansible_influx_db_create.json is defined
    and ansible_influx_db_create.json.results[0].statement_id == 0

- name: '{{db_prefix}} Get SOURCE retention policies'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.source.name}}" method=POST body="q=SHOW RETENTION POLICIES" return_content=yes
  register: ansible_influx_source_rps
  when: ifx_db.source is defined

# do not check for source/target measurements when 'compact': influxdb only shows measurements of all RPs per DB
- name: '{{db_prefix}} Get SOURCE measurements'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.source.name}}" method=POST body="q=SHOW MEASUREMENTS" return_content=yes
  register: ansible_influx_source_mms
  when: ifx_db.source is defined and not ifx_source_drop

- name: '{{db_prefix}} Get TARGET retention policies'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.name}}" method=POST body="q=SHOW RETENTION POLICIES" return_content=yes
  register: ansible_influx_rps
  when: ansible_influx_db_create is not changed

- name: '{{db_prefix}} Get TARGET measurements'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.name}}" method=POST body="q=SHOW MEASUREMENTS" return_content=yes
  register: ansible_influx_mms
  when: ansible_influx_db_create is not changed and not ifx_source_drop

- name: '{{db_prefix}} List of retention policies and measurements'
  set_fact:
    ifx_rps: "{{ansible_influx_rps.json.results
      |selectattr('series','defined')|map(attribute='series')|flatten
      |selectattr('values','sequence')|map(attribute='values')|flatten
      if ansible_influx_db_create is not changed else []}}"
    ifx_source_rps: "{{ansible_influx_source_rps.json.results
      |selectattr('series','defined')|map(attribute='series')|flatten
      |selectattr('values','sequence')|map(attribute='values')|flatten
      if ifx_db.source is defined else []}}"
    ifx_mms: "{{ansible_influx_mms.json.results
      |selectattr('series', 'defined')|map(attribute='series')|flatten
      |rejectattr('values', 'callable')|map(attribute='values')|flatten
      if ansible_influx_mms is not skipped and ansible_influx_mms.json.results is defined else []}}"
    ifx_source_mms: "{{ansible_influx_source_mms.json.results
      |selectattr('series','defined')|map(attribute='series')|flatten
      |rejectattr('values', 'callable')|map(attribute='values')|flatten
      if ansible_influx_source_mms is not skipped and ansible_influx_source_mms.json.results is defined else []}}"

- name: '{{db_prefix}} Set dependent facts'
  set_fact:
    # assume default exists when referencing default!
    ifx_source_exists: "{{ifx_db.source.rp_name in ifx_source_rps 
      if ifx_db.source is defined and ifx_source_rp_name != '' else false}}"
    # set empty groupby if interval = * (to avoid group by *, *)
    ifx_cq_groupby: "{{[] if ifx_cq_interval == '*' else ifx_cq_groupby}}"
    # register start time of backfilling
    ifx_backfill_start: "{{lookup('pipe','date +%s')}}"

- name: '{{db_prefix}} Source must exist for compact'
  debug: msg="Source '{{ifx_db.source.name}}.{{ifx_source_rp_name}}' must exist, will skip measurements and backfill"
  when: ifx_source_drop and not ifx_source_exists

- name: '{{db_prefix}} Print SOURCE  measurements'
  debug: msg="List of measurements on SOURCE = {{ifx_source_mms|join(', ')}}"
  when: ifx_db.source is defined and not ifx_source_drop and ifx_source_exists
  failed_when: ifx_source_mms|length == 0

- name: '{{db_prefix}} Print TARGET measurements'
  debug: msg="List of measurements on TARGET = {{ifx_mms|join(', ')}}"
  when: ifx_mms|length > 0

- name: '{{db_prefix}} Create retention policy {{ifx_rp_name}}'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    body: >
      q=CREATE RETENTION POLICY "{{ifx_rp_name}}" ON "{{ifx_db.name}}"
      DURATION {{ifx_rp_duration}} REPLICATION 1 {{ifx_rp_default}}
    return_content: yes
  when: ansible_influx_db_create is changed or (ifx_rps is defined and ifx_rp_name not in ifx_rps)
  register: ansible_influx_rp_create
  changed_when: ansible_influx_rp_create.status == 200 and ansible_influx_rp_create.json is defined
    and ansible_influx_rp_create.json.results[0].statement_id == 0

- name: '{{db_prefix}} Create measurements'
  include_tasks: influxdb_measurement.yml measurement={{mm_item}}
  with_items: "{{ifx_db.measurements|sort}}"
  loop_control: { loop_var: mm_item }
  when: ifx_db.measurements is defined and (ifx_source_exists or ifx_source_rp_name == '')
    and (ifx_cq_recreate or ansible_influx_db_create is changed or mm_item not in ifx_mms or ifx_backfill_force)

- pause:
    prompt: "I will now backfill gap and switch default RP, Continue?" 
  when: ifx_source_drop and ifx_source_exists

# run twice -> sum up results
- set_fact:
    ifx_backfill_start2: "{{lookup('pipe','date +%s')}}"
- name: '{{db_prefix}} Backfill again (1) since start (close gap)'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    body: >
      q=SELECT * INTO "{{ifx_db.name}}"."{{ifx_rp_name}}".:MEASUREMENT
      FROM "{{ifx_db.source.name}}"."{{ifx_source_rp_name}}"./^({{ifx_db.measurements|join('|')}})$/
      WHERE time >= {{ifx_backfill_start}}000ms
      GROUP BY *
    return_content: yes
  register: ansible_influx_bf_closegap
  when: ifx_source_drop and ifx_source_exists

- name: '{{db_prefix}} Backfill again (2) since start (close gap)'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    body: >
      q=SELECT * INTO "{{ifx_db.name}}"."{{ifx_rp_name}}".:MEASUREMENT
      FROM "{{ifx_db.source.name}}"."{{ifx_source_rp_name}}"./^({{ifx_db.measurements|join('|')}})$/
      WHERE time >= {{ifx_backfill_start2}}000ms
      GROUP BY *
    return_content: yes
  register: ansible_influx_bf_closegap2
  when: ifx_source_drop and ifx_source_exists

# DID not work :(
- name: '{{db_prefix}} Get backfill points written'
  set_fact:
    db_backfill_closegap: "{{ansible_influx_bf_closegap.json.results
      |selectattr('series', 'defined')|map(attribute='series')|flatten
      |map(attribute='values')|flatten|select('number')|map('int')|sum(start=0)}}"
    db_backfill_closegap2: "{{ansible_influx_bf_closegap2.json.results
      |selectattr('series', 'defined')|map(attribute='series')|flatten
      |map(attribute='values')|flatten|select('number')|map('int')|sum(start=0)}}"
  when: ansible_influx_bf_closegap is not skipped

- debug: msg="{{ansible_influx_bf_closegap.json.results
      |selectattr('series', 'defined')|map(attribute='series')|flatten
      |map(attribute='values')|flatten}}"
  when: ansible_influx_bf_closegap is not skipped

- name: '{{db_prefix}} Backfill again points written'
  debug: msg="Total data points written = {{db_backfill_closegap+db_backfill_closegap2}}"
  when: ansible_influx_bf_closegap is not skipped

- name: '{{db_prefix}} Make RP the default'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    body: >
      q=ALTER RETENTION POLICY "{{ifx_rp_name}}" ON "{{ifx_db.name}}" DEFAULT
    return_content: yes
  register: ansible_influx_rp_alter
  when: ifx_source_drop and ifx_source_exists
  changed_when: ansible_influx_rp_alter.status == 200 and ansible_influx_rp_alter.json is defined
    and ansible_influx_rp_alter.json.results[0].statement_id == 0

- name: '{{db_prefix}} Total data points written'
  debug: msg="Total data points written = {{mm_backfill_totals|map('int')|sum(start=0)}}"
  when: ifx_backfill

- name: '{{db_prefix}} Average series downsampling'
  debug: msg="Average series downsampling = {{ (mm_downsampling_totals|map('float')|sum(start=0) / mm_downsampling_totals|length) |round(2) }} %"
  when: ifx_backfill and mm_downsampling_totals|length > 0

- name: '{{db_prefix}} Total duration'
  debug: msg="Total duration = {{(lookup('pipe','date +%s')|int - ifx_backfill_start|int)/60}} minutes"

# TODO: error in setup: cannot compact without naming old retention policy
- name: '{{db_prefix}} Drop old RP (compact)'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    body: >
      q=DROP RETENTION POLICY "{{ifx_db.source.rp_name}}" ON "{{ifx_db.source.name}}"
    return_content: yes
  register: ansible_influx_source_drop
  when: ifx_source_drop and ifx_source_exists and ifx_source_rp_name != ''


---

- name: '{{ifx_db.name}}/{{measurement}} - Set measurement variable'
  set_fact:
    ifx_mm: "{{ifx_db.measurements[measurement]}}"
    ifx_cq_name: "cq_{{measurement}}_{{ifx_cq_interval}}"
    ifx_mm_name: '"{{measurement}}"'

- name: '{{ifx_db.name}}/{{measurement}} - Set defaults'
  set_fact:
    mm_prefix: "{{ifx_db.name}}/{{measurement}} -"
    source_mm: "{{'\"'+ifx_db.source.name+'\".\"'+ifx_db.source.rp_name+'\".\"'+measurement+'\"' if ifx_db.source is defined else ''}}"
    target_mm: '"{{ifx_db.name}}"."{{ifx_db.rp_name}}"."{{measurement}}"'
    cq_select: "{{ifx_mm.select if ifx_mm.select is defined else ansible_influx_queries[measurement]}}"
    bf_where: "{{'AND '+ifx_mm.where if ifx_mm.where is defined else ifx_bf_where}}"
    cq_groupby:  "{{ifx_mm.groupby if ifx_mm.groupby is defined else ifx_cq_groupby}}"
    cq_where: "{{'WHERE '+ifx_mm.where if ifx_mm.where is defined else ifx_cq_where}}"
    cq_interval: "{{ifx_mm.interval if ifx_mm.interval is defined else ifx_cq_interval}}"
    cq_resample: "{{'RESAMPLE' if ifx_mm.every is defined or ifx_mm.for is defined else ifx_cq_resample}}"
    cq_resample_every: "{{'EVERY '+ifx_mm.every if ifx_mm.every is defined else ifx_cq_resample_every}}"
    cq_resample_for: "{{'FOR '+ifx_mm.for if ifx_mm.for is defined else ifx_cq_resample_for}}"
    mm_count_source: 0
    mm_backfill: "{{ifx_mm.backfill if ifx_mm.backfill is defined else ifx_backfill}}"
    mm_backfill_result: 0

- name: '{{mm_prefix}} Get fields from source'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.source.name}}" method=POST body="q=SHOW FIELD KEYS FROM {{measurement}}" return_content=yes
  register: ansible_influx_mm_fields
  when: ifx_db.source is defined

- name: '{{mm_prefix}} Get SOURCE measurement count(*)'
  uri: 
    url: "{{ansible_influx_url}}/query?db={{ifx_db.source.name}}" 
    method: POST 
    body: "q=SELECT COUNT(*) FROM {{measurement}} WHERE time >= now() - {{ifx_db.retention_policy.amount+ifx_db.retention_policy.unit}}"
    return_content: yes
  register: ansible_influx_mm_count
  when: mm_backfill and measurement not in ifx_mms and ifx_db.source is defined
    and ifx_backfill_stats

- name: '{{mm_prefix}} Cacluate SOURCE measurement count'
  set_fact:
    mm_count_source: "{{ansible_influx_mm_count.json.results|map(attribute='series')|flatten|map(attribute='values')|flatten|select('number')|map('int')|max}}"
  when: ansible_influx_mm_count.json is defined and ansible_influx_mm_count.json.results[0].series is defined

- name: '{{mm_prefix}} Count on SOURCE'
  debug: msg="Max count on SOURCE {{measurement}} = {{mm_count_source}}"
  when: mm_count_source|int > 0 

- name: '{{mm_prefix}} Create list of fields'
  set_fact:
    ifx_mm_fields: "{{ansible_influx_mm_fields.json.results[0].series|rejectattr('values', 'callable') |map(attribute='values') |flatten |select('match', '^(?!integer|float|string).*$')|list|default([])}}"

- name: '{{mm_prefix}} List fields'
  debug: msg="Fields of {{measurement}} - {{ifx_mm_fields|join(',')}}"

- name: '{{mm_prefix}} Backfilling measurement'
  uri:
    url: "{{ansible_influx_url}}/query?db={{ifx_db.name}}"
    method: POST
    timeout: "{{ansible_influx_timeout}}"
    # now() - rp.amount+rp.unit - x*bf.step
    body: >
      q={{cq_select}} INTO {{target_mm}} FROM {{source_mm}}
      WHERE time >= now() - {{seq}}{{ifx_db.retention_policy.unit}} 
      AND time < now() - {{seq|int - ifx_db.backfill.step|int}}{{ifx_db.retention_policy.unit}}
      {{bf_where}} GROUP BY time({{cq_interval}}),{{cq_groupby|join(',')}}
    return_content: yes
  with_sequence: start={{ifx_db.retention_policy.amount|int}} end={{ifx_db.backfill.step|int}} stride=-{{ifx_db.backfill.step|int}}
  loop_control: { loop_var: seq }
  when: mm_backfill and measurement not in ifx_mms and ifx_db.source is defined
    and (
      (ansible_influx_mm_count.json is defined and ansible_influx_mm_count.json.results[0].series is defined)
      or not ifx_backfill_stats
    )
  register: ansible_influx_mm_backfill
  changed_when: ansible_influx_mm_backfill.json is defined and ansible_influx_mm_backfill.json.results is defined and ansible_influx_mm_backfill.json.results[0].statement_id == 0
  failed_when: ansible_influx_mm_backfill.rc|default(0) == 1 or (ansible_influx_mm_backfill.json is defined and ansible_influx_mm_backfill.json.results is defined and ansible_influx_mm_backfill.json.results[0].error is defined)

- name: '{{mm_prefix}} Print result from backfill'
  debug: var=ansible_influx_mm_backfill
  when: (ansible_influx_mm_backfill is succeeded 
    and ansible_influx_mm_backfill is not changed 
    and (ansible_influx_mm_backfill.results|map(attribute='skipped')|flatten|default([])|unique != [ true ])) 
    or ansible_influx_mm_backfill is failed

- name: '{{mm_prefix}} Sum up written data points'
  set_fact:
    mm_backfill_result: "{{ansible_influx_mm_backfill.results |map(attribute='json.results')|flatten |map(attribute='series')|flatten |map(attribute='values')|flatten |select('number')|map('int')|sum(start=0)}}"
  when: mm_backfill and ansible_influx_mm_backfill is changed

- name: '{{mm_prefix}} Backfill results'
  debug: msg="Total data points written = {{mm_backfill_result}}"
  when: mm_backfill and ansible_influx_mm_backfill is changed

- name: '{{mm_prefix}} Drop continuous query {{ifx_cq_name}}'
  uri: 
    url: "{{ansible_influx_url}}/query" 
    method: POST 
    body: 'q=DROP CONTINUOUS QUERY "{{ifx_cq_name}}" ON "{{ifx_db.name}}"'
  when: ifx_db.source is defined and ifx_cq_name in ifx_cqs

- name: '{{mm_prefix}} Creating continuous query {{ifx_cq_name}}'
  uri:
    url: "{{ansible_influx_url}}/query"
    method: POST
    body: >
      q=CREATE CONTINUOUS QUERY "{{ifx_cq_name}}" ON "{{ifx_db.name}}"
      {{cq_resample}} {{cq_resample_every}} {{cq_resample_for}}
      BEGIN {{cq_select}} INTO {{target_mm}} FROM {{source_mm}} {{cq_where}}
      GROUP BY time({{cq_interval}}),{{cq_groupby|join(',')}} END
    return_content: yes
  register: ansible_influx_mm_cq
  when: ifx_db.source is defined

- name: '{{mm_prefix}} Get TARGET measurement count(*)'
  uri: url="{{ansible_influx_url}}/query?db={{ifx_db.name}}" method=POST body="q=SELECT COUNT(*) FROM {{measurement}}" return_content=yes
  register: ansible_influx_mm_count
  when: mm_backfill and ifx_db.source is defined and mm_backfill_result|int > 0

- name: '{{mm_prefix}} Calcuate TARGET measurement count'
  set_fact:
    mm_count: "{{ansible_influx_mm_count.json.results[0].series|default([])|map(attribute='values')|flatten|select('number')|map('int')|max}}"
  when: mm_backfill_result|int > 0

- name: '{{mm_prefix}} Count on TARGET'
  debug: msg="Max count on TARGET {{measurement}} = {{mm_count}}"
  when: mm_backfill_result|int > 0

- name: '{{mm_prefix}} Series downsampling'
  debug: msg="{{mm_count}}/{{mm_count_source}} = {{(mm_count|int/mm_count_source|int*100)|round(2)}} %"
  when: mm_backfill_result|int > 0 and ifx_backfill_stats

- name: '{{mm_prefix}} Collect stats'
  set_fact:
    mm_backfill_totals: "{{mm_backfill_totals|union([ mm_backfill_result ])}}"
    mm_downsampling_totals: "{{mm_downsampling_totals|union([ mm_count|int/mm_count_source|int*100 ]) if ifx_backfill_stats else mm_downsampling_totals}}"
  when: mm_backfill_result|int > 0

